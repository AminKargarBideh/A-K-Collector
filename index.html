<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>V2Ray Config Dashboard</title>
    <meta name="description" content="A live dashboard of validated V2Ray configurations.">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { padding: 2rem; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem; }
        .card {
            background-color: var(--card-background-color);
            border: var(--card-border);
            border-radius: var(--border-radius);
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #search { margin-bottom: 1rem; }
        td button { margin: 0; padding: 0.2rem 0.5rem; }
        .copied-feedback { color: var(--pico-color-green-400); font-weight: bold; }
        .chart-container { position: relative; height: 300px; width: 100%; }
        #subscription-link { font-size: 1.1rem; }
        #configsTable tbody tr:hover {
            background-color: var(--card-background-color);
        }
        h2 { text-align: center; }
        
        /* New styles for the subscription link container using CSS Grid */
        .sub-container {
            display: grid;
            grid-template-columns: 1fr auto; /* Link takes all space, button takes auto space */
            align-items: center;
            gap: 0.5rem;
        }
        .sub-container code {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .sub-container button {
            margin: 0;
            padding: 0.2rem 0.6rem;
            font-size: 0.8em;
        }
    </style>
</head>
<body>
    <main class="container">
        <header>
            <h1 style="text-align: center;">üöÄ V2Ray Config Dashboard</h1>
            <p style="text-align: center;">Live, validated, and enriched V2Ray configurations.</p>
           <label style="position: absolute; top: 1rem; right: 1rem;">
               <input type="checkbox" id="theme-toggle" role="switch">
               Dark Mode
           </label>
        </header>

        <section id="stats" class="grid"></section>
        
        <div class="grid">
            <article class="card">
                <h2>üåç Configs by Country</h2>
                <div class="chart-container"><canvas id="countryChart"></canvas></div>
            </article>
            <article class="card">
                <h2>üìä Configs by Protocol</h2>
                <div class="chart-container"><canvas id="protocolChart"></canvas></div>
            </article>
        </div>
        <article>
           <header>
                <h2>üì¢ Channel Statistics</h2>
           </header>
           <div style="overflow: auto; height: 250px;">
               <table id="channelStatsTable">
                   <thead>
                       <tr><th>Channel</th><th>Extracted Configs</th><th>Subscription</th></tr>
                   </thead>
                   <tbody></tbody>
               </table>
           </div>
       </article>

        <article>
            <header>
                <h2>Filter & Generate Configurations</h2>
                <div class="grid">
                    <select id="country-select">
                        <option value="">Select a Country</option>
                    </select>
                    <select id="protocol-select">
                        <option value="">Select a Protocol</option>
                    </select>
                </div>
                <div class="grid" style="margin-top: 1rem;">
                    <input type="number" id="config-count" name="config-count" placeholder="Number of configs (e.g., 20)" value="20">
                    <button id="generate-sub-btn" aria-busy="false">Generate & Copy Link</button>
                </div>
            </header>

            <div id="subscription-container" style="display: none; margin-bottom: 1rem;">
                <h4 id="subscription-title" style="margin-bottom: 0.5rem;"></h4>
                <div class="sub-container">
                    <code id="subscription-link"></code>
                    <button id="copy-subscription-btn" class="outline">Copy</button>
                </div>
            </div>

            <div id="configs-container" style="display: none;">
                <h2>Available Configurations</h2>
                <div style="overflow-x: auto;">
                    <table id="configsTable">
                        <thead>
                            <tr><th>Name</th><th>Protocol</th><th>Country</th><th>ISP</th><th>Action</th></tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <footer>
                <p>Last updated: <span id="lastUpdated"></span></p>
            </footer>
        </article>

            <div id="custom-sub-container" style="display: none; margin-top: 1rem;">
               <h4 id="custom-sub-title" style="margin-bottom: 0.5rem;"></h4>
               <div class="sub-container">
                   <code id="custom-sub-link"></code>
                   <button id="copy-custom-sub-btn" class="outline">Copy</button>
               </div>
            </div>

    </main>

        <script>
        document.addEventListener('DOMContentLoaded', () => {
            const API_URL = './validated_configs/results.json';
            const configsTableBody = document.querySelector('#configsTable tbody');
            const statsContainer = document.getElementById('stats');
            const lastUpdatedSpan = document.getElementById('lastUpdated');
            const countrySelect = document.getElementById('country-select');
            const protocolSelect = document.getElementById('protocol-select');
            const subscriptionContainer = document.getElementById('subscription-container');
            const subscriptionTitle = document.getElementById('subscription-title');
            const subscriptionLinkElem = document.getElementById('subscription-link');
            const copySubscriptionBtn = document.getElementById('copy-subscription-btn');
            const configsContainer = document.getElementById('configs-container');
            const channelStatsTableBody = document.querySelector('#channelStatsTable tbody');
            
            // New Elements for Custom Subscription
            const generateSubBtn = document.getElementById('generate-sub-btn');
            const configCountInput = document.getElementById('config-count');
            const customSubContainer = document.getElementById('custom-sub-container');
            const customSubTitle = document.getElementById('custom-sub-title');
            const customSubLinkElem = document.getElementById('custom-sub-link');
            const copyCustomSubBtn = document.getElementById('copy-custom-sub-btn');

           let allConfigs = [];
           let countryChart, protocolChart;

           async function fetchData() {
               try {
                   const response = await fetch(`${API_URL}?t=${new Date().getTime()}`);
                   if (!response.ok) {
                       // If the main file is missing, the page is unusable.
                       document.querySelector('main').innerHTML = `
                           <article>
                               <h2>Error</h2>
                               <p>Could not load the configuration file (<code>${API_URL}</code>).</p>
                               <p>Please make sure the scraper has been run successfully at least once.</p>
                               <p>Run <code>python v2ray_collector3.py scrape</code> and then restart the web server.</p>
                           </article>`;
                       throw new Error(`HTTP error! status: ${response.status}`);
                   }
                   const data = await response.json();
                   
                   allConfigs = data;
                   
                   const fileDate = response.headers.get("last-modified") ? new Date(response.headers.get("last-modified")) : new Date();
                   lastUpdatedSpan.textContent = fileDate.toLocaleString();
                   
                   // Initial population of dropdowns with all configs and then handle initial filter state
                   updateCountryDropdown(allConfigs, countrySelect.value, protocolSelect.value);
                   updateProtocolDropdown(allConfigs, countrySelect.value, protocolSelect.value);
                   handleFilterChange(); // Call once to set initial state correctly
                   renderStats(allConfigs);
                   renderCharts(allConfigs);
                   renderChannelStats(allConfigs);
               } catch (error) {
                   console.error("Failed to fetch config data:", error);
               }
           }

           function updateCountryDropdown(currentConfigs, selectedCountry, selectedProtocol) {
               countrySelect.innerHTML = '<option value="">Select a Country</option>'; // Always keep default option

               const countryCounts = {};
               currentConfigs.forEach(c => {
                   // Calculate counts based on the *other* filter (selectedProtocol)
                   if (!selectedProtocol || c.protocol === selectedProtocol) {
                       countryCounts[c.country_name] = (countryCounts[c.country_name] || 0) + 1;
                   }
               });

               const sortedCountries = Object.keys(countryCounts).sort();
               sortedCountries.forEach(country => {
                   const option = document.createElement('option');
                   option.value = country;
                   option.textContent = `${country} (${countryCounts[country]})`;
                   countrySelect.appendChild(option);
               });
               countrySelect.value = selectedCountry; // Restore selection
           }

           function updateProtocolDropdown(currentConfigs, selectedCountry, selectedProtocol) {
               protocolSelect.innerHTML = '<option value="">Select a Protocol</option>'; // Always keep default option

               const protocolCounts = {};
               currentConfigs.forEach(c => {
                   // Calculate counts based on the *other* filter (selectedCountry)
                   if (!selectedCountry || c.country_name === selectedCountry) {
                       protocolCounts[c.protocol] = (protocolCounts[c.protocol] || 0) + 1;
                   }
               });

               const sortedProtocols = Object.keys(protocolCounts).sort();
               sortedProtocols.forEach(protocol => {
                   const option = document.createElement('option');
                   option.value = protocol;
                   option.textContent = `${protocol} (${protocolCounts[protocol]})`;
                   protocolSelect.appendChild(option);
               });
               protocolSelect.value = selectedProtocol; // Restore selection
           }
 
           function handleFilterChange() {
               const selectedCountry = countrySelect.value;
               const selectedProtocol = protocolSelect.value;

               // Update both dropdowns with counts reflecting the *other* filter
               updateCountryDropdown(allConfigs, selectedCountry, selectedProtocol);
               updateProtocolDropdown(allConfigs, selectedCountry, selectedProtocol);
 
               // Determine the final set of configs to display in the table and generate subscription link
               let finalFilteredConfigs = allConfigs;
               if (selectedCountry) {
                   finalFilteredConfigs = finalFilteredConfigs.filter(c => c.country_name === selectedCountry);
               }
               if (selectedProtocol) {
                   finalFilteredConfigs = finalFilteredConfigs.filter(c => c.protocol === selectedProtocol);
               }
               
               // Show/hide subscription link and configs table
               if (!selectedCountry && !selectedProtocol) {
                   subscriptionContainer.style.display = 'none';
                   configsContainer.style.display = 'none';
               } else {
                   let title = 'Subscription Link for';
                   let subLink = '';
 
                   if (selectedCountry) {
                       title += ` ${selectedCountry}`;
                       const countryCode = allConfigs.find(c => c.country_name === selectedCountry)?.country_code;
                       if (countryCode) {
                           subLink = `${window.location.origin}${window.location.pathname.replace(/\/$/, '')}/validated_configs/by-country/${countryCode}.txt`;
                       }
                   }
 
                   if (selectedProtocol) {
                       title += ` ${selectedProtocol}`;
                       // If only protocol is selected, or if country filter is empty, use protocol-specific link
                       if (!selectedCountry || (selectedCountry && !finalFilteredConfigs.some(c => c.country_name === selectedCountry))) {
                           subLink = `${window.location.origin}${window.location.pathname.replace(/\/$/, '')}/validated_configs/${selectedProtocol}.txt`;
                       }
                   }
                   
                   subscriptionTitle.textContent = title;
                   subscriptionLinkElem.textContent = subLink;
                   subscriptionContainer.style.display = 'block';
                   configsContainer.style.display = 'block';
               }
 
               renderTable(finalFilteredConfigs);
           }

           function renderTable(configs) {
               configsTableBody.innerHTML = '';
               if (configs.length === 0) {
                   configsTableBody.innerHTML = `<tr><td colspan="5" style="text-align:center;">No matching configurations found.</td></tr>`;
                   return;
               }
               configs.forEach(config => {
                   const row = document.createElement('tr');
                   const displayName = config.display_name || config.name;
                   const configToCopy = config.renamed_config || config.config;
                   
                   row.innerHTML = `
                       <td>${displayName}</td>
                       <td>${config.protocol}</td>
                       <td>${config.country_name}</td>
                       <td>${config.isp}</td>
                       <td><button class="copy-btn" data-config="${configToCopy}">Copy Config</button></td>
                   `;
                   configsTableBody.appendChild(row);
               });
           }

           // Event Listeners
           countrySelect.addEventListener('change', handleFilterChange);
           protocolSelect.addEventListener('change', handleFilterChange);

           function copyToClipboard(text, buttonElement) {
               if (navigator.clipboard && navigator.clipboard.writeText) {
                   navigator.clipboard.writeText(text).then(() => {
                       const originalText = buttonElement.textContent;
                       buttonElement.textContent = 'Copied!';
                       setTimeout(() => { buttonElement.textContent = originalText; }, 2000);
                   }).catch(err => {
                       console.error('Failed to copy using clipboard API:', err);
                       fallbackCopyToClipboard(text, buttonElement);
                   });
               } else {
                   fallbackCopyToClipboard(text, buttonElement);
               }
           }

           function fallbackCopyToClipboard(text, buttonElement) {
               const textArea = document.createElement("textarea");
               textArea.value = text;
               textArea.style.position = "fixed";  // Avoid scrolling to bottom
               textArea.style.left = "-9999px"; // Move outside the screen
               document.body.appendChild(textArea);
               textArea.focus();
               textArea.select();
               try {
                   document.execCommand('copy');
                   const originalText = buttonElement.textContent;
                   buttonElement.textContent = 'Copied!';
                   setTimeout(() => { buttonElement.textContent = originalText; }, 2000);
               } catch (err) {
                   console.error('Fallback: Oops, unable to copy', err);
                   alert("Failed to copy. Please copy the link manually: " + text);
               }
               document.body.removeChild(textArea);
           }

           copySubscriptionBtn.addEventListener('click', () => {
               copyToClipboard(subscriptionLinkElem.textContent, copySubscriptionBtn);
           });

           channelStatsTableBody.addEventListener('click', e => {
                if (e.target.classList.contains('copy-channel-sub')) {
                    const button = e.target;
                    const link = button.dataset.link;
                    copyToClipboard(link, button);
                }
           });

           configsTableBody.addEventListener('click', e => {
               if (e.target.classList.contains('copy-btn')) {
                   const button = e.target;
                   const configStr = button.dataset.config;
                   copyToClipboard(configStr, button);
               }
           });

           // --- Custom Subscription Generator Logic ---
           async function generateCustomSubscription() {
               const country = countrySelect.value;
               const protocol = protocolSelect.value;
               const count = configCountInput.value || 20;

               // Show loading state
               generateSubBtn.setAttribute('aria-busy', 'true');
               generateSubBtn.disabled = true;

               const params = new URLSearchParams();
               if (country) params.append('country', country);
               if (protocol) params.append('protocol', protocol);
               params.append('count', count);

               try {
                   const response = await fetch(`/api/generate_sub?${params.toString()}`);
                   if (!response.ok) {
                       const errorData = await response.json();
                       throw new Error(errorData.error || 'Failed to generate subscription.');
                   }
                   const data = await response.json();
                   
                   if(data.subscription_link) {
                       customSubLinkElem.textContent = data.subscription_link;
                       customSubTitle.textContent = `Generated link with ${data.config_count} configs.`;
                       customSubContainer.style.display = 'block';
                       // Auto-copy to clipboard
                       copyToClipboard(data.subscription_link, generateSubBtn);
                   } else {
                       customSubTitle.textContent = data.message || "No configs found for the selected criteria.";
                       customSubLinkElem.textContent = '';
                       customSubContainer.style.display = 'block';
                   }

               } catch (error) {
                   customSubTitle.textContent = `Error: ${error.message}`;
                   customSubLinkElem.textContent = '';
                   customSubContainer.style.display = 'block';
                   console.error("Custom subscription error:", error);
               } finally {
                   // Hide loading state
                   generateSubBtn.setAttribute('aria-busy', 'false');
                   generateSubBtn.disabled = false;
               }
           }

           copyCustomSubBtn.addEventListener('click', () => {
               navigator.clipboard.writeText(customSubLinkElem.textContent).then(() => {
                   copyCustomSubBtn.textContent = 'Copied!';
                   setTimeout(() => { copyCustomSubBtn.textContent = 'Copy'; }, 2000);
               });
           });

           generateSubBtn.addEventListener('click', generateCustomSubscription);

           const themeToggle = document.getElementById('theme-toggle');
           
           function setTheme(isDark) {
               document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
               themeToggle.checked = isDark;
           }

           themeToggle.addEventListener('change', () => {
               setTheme(themeToggle.checked);
           });

           // Set initial theme based on system preference
           const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
           setTheme(prefersDark);

            // Chart and Stat rendering functions
            function renderStats(configs) {
                const totalConfigs = configs.length;
                const countries = new Set(configs.map(c => c.country_name)).size;
                const protocols = new Set(configs.map(c => c.protocol)).size;
                statsContainer.innerHTML = `<div class="card"><h3>Total Valid Configs</h3><p style="font-size: 2rem; margin:0;">${totalConfigs}</p></div><div class="card"><h3>Countries</h3><p style="font-size: 2rem; margin:0;">${countries}</p></div><div class="card"><h3>Protocols</h3><p style="font-size: 2rem; margin:0;">${protocols}</p></div>`;
            }

            function renderCharts(configs) {
                const processChartData = (data, topN = 10) => {
                    const sortedData = Object.entries(data).sort(([, a], [, b]) => b - a);
                    const labels = [], values = [];
                    const topItems = sortedData.slice(0, topN);
                    topItems.forEach(([label, value]) => { labels.push(label); values.push(value); });
                    if (sortedData.length > topN) {
                        const otherItems = sortedData.slice(topN);
                        const otherValue = otherItems.reduce((sum, [, value]) => sum + value, 0);
                        labels.push("Other");
                        values.push(otherValue);
                    }
                    return { labels, values };
                };
                const countryData = configs.reduce((acc, c) => {
                    const country = c.country_name || "Unknown";
                    acc[country] = (acc[country] || 0) + 1;
                    return acc;
                }, {});
                const processedCountryData = processChartData(countryData, 9);
                if (countryChart) countryChart.destroy();
                countryChart = new Chart(document.getElementById('countryChart'), { type: 'bar', data: { labels: processedCountryData.labels, datasets: [{ label: 'Configs', data: processedCountryData.values }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } } } });
                const protocolData = configs.reduce((acc, c) => { acc[c.protocol] = (acc[c.protocol] || 0) + 1; return acc; }, {});
                const processedProtocolData = { labels: Object.keys(protocolData), values: Object.values(protocolData) };
                if (protocolChart) protocolChart.destroy();
                protocolChart = new Chart(document.getElementById('protocolChart'), { type: 'pie', data: { labels: processedProtocolData.labels, datasets: [{ data: processedProtocolData.values }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'top' } } } });
            }

           function renderChannelStats(configs) {
               const channelStats = configs.reduce((acc, config) => {
                   const channel = config.channel || "Unknown";
                   acc[channel] = (acc[channel] || 0) + 1;
                   return acc;
               }, {});

               const sortedChannels = Object.entries(channelStats).sort(([, a], [, b]) => b - a);

               channelStatsTableBody.innerHTML = '';
               sortedChannels.forEach(([channel, count]) => {
                   const row = document.createElement('tr');
                   const subLink = `${window.location.origin}${window.location.pathname.replace(/\/$/, '')}/validated_configs/by-channel/${channel}.txt`;
                   row.innerHTML = `
                       <td><a href="https://t.me/s/${channel}" target="_blank">${channel}</a></td>
                       <td>${count}</td>
                       <td><button class="copy-channel-sub" data-link="${subLink}">Copy Sub</button></td>
                   `;
                   channelStatsTableBody.appendChild(row);
               });
           }

            // Initial fetch
            fetchData();
        });
    </script>
</body>
</html>
